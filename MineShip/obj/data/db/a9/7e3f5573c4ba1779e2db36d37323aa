/// <summary>
/// Computes the lighting per pixel from multiple directional lights. The first light is the only one to produce a specular component.
/// </summary>
/// <remarks>
/// MAX_LIGHT_COUNT: Macro - maximum number of lights.
/// </remarks>
class LightMultiDirectionalShadingPerPixel<int MAX_LIGHT_COUNT> : ShadingBase
{
    BRDFDiffuseBase brdfDiffuse = stage;
    BRDFSpecularBase brdfSpecular = stage;
    AlbedoDiffuseBase albedoDiffuseBase = stage;
    AlbedoSpecularBase albedoSpecularBase = stage;
    NormalVSBase normal = stage;
    PositionVSBase position = stage;

    cbuffer PerPass
    {
		stage float3 LightDirectionsVS[MAX_LIGHT_COUNT] = null;
		[Color] stage float3 LightColorsWithGamma[MAX_LIGHT_COUNT] = null;
        stage float LightIntensities[MAX_LIGHT_COUNT] = null;
	}
        
    stage override float4 Shading()
	{
        float3 normalVS = normal.NormalVS();
        float3 positionVS = position.PositionVS();
        float3 eyeVS = -normalize(positionVS);

		float3 lighting = 0.0f;
        float4 diffuseAlbedo = albedoDiffuseBase.DiffuseAlbedo();
        float3 specularAlbedo = albedoSpecularBase.SpecularAlbedo();
		
        if (MAX_LIGHT_COUNT >= 1)
		{
			float3 lightDirectionVS = normalize(-LightDirectionsVS[0]);

			float3 lightColor = LightColorsWithGamma[0];
			lighting += LightIntensities[0] * brdfDiffuse.ComputeDiffuseColor(diffuseAlbedo, lightDirectionVS, normalVS, eyeVS) * brdfDiffuse.ComputeDiffuseLighting(lightColor, lightDirectionVS, normalVS, eyeVS);
			lighting += LightIntensities[0] * brdfSpecular.ComputeSpecularColor(specularAlbedo, lightDirectionVS, normalVS, eyeVS) * brdfSpecular.ComputeSpecularLighting(lightColor, lightDirectionVS, normalVS, eyeVS);
		}
        
        if (MAX_LIGHT_COUNT >= 2)
        {
		    [unroll]
		    for (int i = 1; i < MAX_LIGHT_COUNT; ++i)
		    {
			    float3 lightDirectionVS = normalize(-LightDirectionsVS[i]);

			    float3 lightColor = LightColorsWithGamma[i];
			    lighting += LightIntensities[i] * brdfDiffuse.ComputeDiffuseColor(diffuseAlbedo, lightDirectionVS, normalVS, eyeVS) * brdfDiffuse.ComputeDiffuseLighting(lightColor, lightDirectionVS, normalVS, eyeVS);
			    // no specular
		    }
        }

		return base.Shading() + float4(lighting, 0.0f);
    }
};
