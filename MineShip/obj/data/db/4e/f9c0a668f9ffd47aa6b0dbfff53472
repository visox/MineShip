/// <summary>
/// Computes lighting prepass from point lights.
/// </summary>
class LightPrepass : ShaderBase, Transformation, PositionStream2, BRDFDiffuseBase, SpecularPowerBase, BRDFSpecularBase, PositionVSBase, NormalVSBase
{
    stage stream /*nointerpolation*/ uint lightIndexID : SV_VertexID;

    struct LightInfo
    {
        float3 vPositionVS;
        float radius;
        float3 color;
        float intensity;
    };

	struct LightInfo2
    {
        int4 index;
    };

	stage int LightCount = 64;
	stage int TileIndex = 0;

    cbuffer LightData
    {
        [Link("LightingPrepassProcessor.LightInfos")]
        stage LightInfo LightInfos[64];
    }

    [Map("LightKeys.LightAttenuationCutoff")]
    stage float LightAttenuationCutoff;

    float CalculateLightAttenuation(float lightDistance, float lightIntensity, float lightRadius, float cutoff)
    {
        // calculate basic attenuation
        float dr = max(lightDistance - lightRadius, 0)/lightRadius + 1;

        // attenuation = Li / (d/r + 1)^2
        float attenuation = lightIntensity / (dr*dr);
    
        // Apply cutoff
        attenuation = (attenuation - cutoff) / (1.0f - cutoff);
        return max(attenuation, 0.0f);
    }

    override void VSMain()
    {
        base.VSMain();

		uint lightIndex = TileIndex;
		uint tileCountX = 16;
		uint tileCountY = 10;
		float2 startXY = float2(lightIndex % tileCountX, lightIndex / tileCountX) / float2(tileCountX, tileCountY) * 2.0 - 1.0;
		float2 vertexPosition = startXY + 1.0f / float2(tileCountX, tileCountY) * 2.0f * ((streams.Position.xy + 1.0f) * 0.5f);

		streams.ShadingPosition = float4(vertexPosition, 0.0f, 1.0f);
    }

    override void PSMain()
    {
        this.GenerateNormalVS_PS();
        float3 positionVS = this.PositionVS();
        float3 eyeVS = -normalize(positionVS);
        float3 normalVS = this.NormalVS();
        float specularPower = this.SpecularPowerValue();

		streams.ColorTarget = 0.0f;

		for (int lightIndex = 0; lightIndex < LightCount; ++lightIndex)
		{
			LightInfo lightInfo = LightInfos[lightIndex];
			float3 lightDir = lightInfo.vPositionVS - positionVS;

			// Normalize lightDir
			float dist = length(lightDir);
			lightDir /= dist;
        
			float3 lightColor = lightInfo.color; // pow(lightInfo.color,2.2);
			lightColor *= CalculateLightAttenuation(dist, lightInfo.intensity, lightInfo.radius, LightAttenuationCutoff);

			// Compute Diffuse Lighting
			float3 diffuseLighting = this.ComputeDiffuseLighting(lightColor, lightDir, normalVS, eyeVS);

			// Compute Specular Lighting
			float3 specularLighting = this.ComputeSpecularLighting(lightColor, lightDir, normalVS, eyeVS);

			// To reduce bandwidth we don't store 2 x (RGBDiffuse + RGBSpecular), we store only the RGBDiffuse + Utilities.Luminance(RGBSpecular)
			// Luminance(lighting.Specular)
			streams.ColorTarget += float4(diffuseLighting, Utilities.Luminance(specularLighting));
		}
    }
};
